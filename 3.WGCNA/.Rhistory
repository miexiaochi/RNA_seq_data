if (sum(!gsg$goodSamples)>0)
printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")))
# Remove the offending genes and samples from the data:
datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}
datExpr0 = as.data.frame(t(WGCNA.fpkm[,-1]))
names(datExpr0) = WGCNA.fpkm$sample;##########如果第一行不是ID命名，就写成fpkm[,1]
rownames(datExpr0) = names(WGCNA.fpkm[,-1])
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
if (!gsg$allOK)
{
if (sum(!gsg$goodGenes)>0)
printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")))
if (sum(!gsg$goodSamples)>0)
printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")))
# Remove the offending genes and samples from the data:
datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}
##filter
meanFPKM=0.5  ###--过滤标准，可以修改
n=nrow(datExpr0)
datExpr0[n+1,]=apply(datExpr0[c(1:nrow(datExpr0)),],2,mean)
datExpr0=datExpr0[1:n,datExpr0[n+1,] > meanFPKM]
# for meanFpkm in row n+1 and it must be above what you set--select meanFpkm>opt$meanFpkm(by rp)
filtered_fpkm=t(datExpr0)
filtered_fpkm=data.frame(rownames(filtered_fpkm),filtered_fpkm)
names(filtered_fpkm)[1]="sample"
head(filtered_fpkm)
write.table(filtered_fpkm, file="mRNA.filter.txt",
row.names=F, col.names=T,quote=FALSE,sep="\t")
# for meanFpkm in row n+1 and it must be above what you set--select meanFpkm>opt$meanFpkm(by rp)
filtered_fpkm=t(datExpr0)
filtered_fpkm=data.frame(rownames(filtered_fpkm),filtered_fpkm)
names(filtered_fpkm)[1]="sample"
head(filtered_fpkm)
write.table(filtered_fpkm, file="mRNA.filter.txt",
row.names=F, col.names=T,quote=FALSE,sep="\t")
sampleTree = hclust(dist(datExpr0), method = "average")
pdf(file = "1.sampleClustering.pdf", width = 15, height = 8)
par(cex = 0.6)
par(mar = c(0,6,6,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 2,
cex.axis = 1.5, cex.main = 2)
##filter
meanFPKM=0.9  ###--过滤标准，可以修改
n=nrow(datExpr0)
datExpr0[n+1,]=apply(datExpr0[c(1:nrow(datExpr0)),],2,mean)
datExpr0=datExpr0[1:n,datExpr0[n+1,] > meanFPKM]
# for meanFpkm in row n+1 and it must be above what you set--select meanFpkm>opt$meanFpkm(by rp)
filtered_fpkm=t(datExpr0)
filtered_fpkm=data.frame(rownames(filtered_fpkm),filtered_fpkm)
names(filtered_fpkm)[1]="sample"
head(filtered_fpkm)
##filter
meanFPKM=0.1  ###--过滤标准，可以修改
n=nrow(datExpr0)
datExpr0[n+1,]=apply(datExpr0[c(1:nrow(datExpr0)),],2,mean)
datExpr0=datExpr0[1:n,datExpr0[n+1,] > meanFPKM]
# for meanFpkm in row n+1 and it must be above what you set--select meanFpkm>opt$meanFpkm(by rp)
filtered_fpkm=t(datExpr0)
filtered_fpkm=data.frame(rownames(filtered_fpkm),filtered_fpkm)
names(filtered_fpkm)[1]="sample"
head(filtered_fpkm)
write.table(filtered_fpkm, file="mRNA.filter.txt",
row.names=F, col.names=T,quote=FALSE,sep="\t")
sampleTree = hclust(dist(datExpr0), method = "average")
pdf(file = "1.sampleClustering.pdf", width = 15, height = 8)
#install.packages("WGCNA")
#BiocManager::install('WGCNA')
library(WGCNA)
options(stringsAsFactors = FALSE)
enableWGCNAThreads()
## 读取txt文件格式数据
WGCNA.fpkm = read.table("FPKM.txt",header=T,
comment.char = "",
check.names=F)
###############
# 读取csv文件格式
#WGCNA.fpkm = read.csv("ExpData_WGCNA.csv", header = T, check.names = F)
dim(WGCNA.fpkm)
names(WGCNA.fpkm)
datExpr0 = as.data.frame(t(WGCNA.fpkm[,-1]))
names(datExpr0) = WGCNA.fpkm$sample;##########如果第一行不是ID命名，就写成fpkm[,1]
rownames(datExpr0) = names(WGCNA.fpkm[,-1])
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
if (!gsg$allOK)
{
if (sum(!gsg$goodGenes)>0)
printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")))
if (sum(!gsg$goodSamples)>0)
printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")))
# Remove the offending genes and samples from the data:
datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}
##filter
meanFPKM=0.1  ###--过滤标准，可以修改
n=nrow(datExpr0)
datExpr0[n+1,]=apply(datExpr0[c(1:nrow(datExpr0)),],2,mean)
datExpr0=datExpr0[1:n,datExpr0[n+1,] > meanFPKM]
# for meanFpkm in row n+1 and it must be above what you set--select meanFpkm>opt$meanFpkm(by rp)
filtered_fpkm=t(datExpr0)
filtered_fpkm=data.frame(rownames(filtered_fpkm),filtered_fpkm)
names(filtered_fpkm)[1]="sample"
head(filtered_fpkm)
write.table(filtered_fpkm, file="mRNA.filter.txt",
row.names=F, col.names=T,quote=FALSE,sep="\t")
sampleTree = hclust(dist(datExpr0), method = "average")
pdf(file = "1.sampleClustering.pdf", width = 15, height = 8)
par(cex = 0.6)
par(mar = c(0,6,6,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 2,
cex.axis = 1.5, cex.main = 2)
### Plot a line to show the cut
#abline(h = 180, col = "red")##剪切高度不确定，故无红线
dev.off()
# 加载必要的R包
library(WGCNA)
options(stringsAsFactors = FALSE)
allowWGCNAThreads()
f=getwd()
# 设置工作目录到数据文件所在的目录
setwd(f)  # 请将此路径修改为实际数据所在路径
# 加载计数数据
counts <- read.csv("merged.counts.txt", sep = "\t", header = TRUE, row.names = 1)
# 确保数据格式正确
datExpr <- as.data.frame(t(counts))
# 检查是否有缺失值
gsg <- goodSamplesGenes(datExpr, verbose = 3)
if (!gsg$allOK) {
# 如果有缺失值或异常值，进行处理
datExpr <- datExpr[gsg$goodSamples, gsg$goodGenes]
}
# 样本信息数据框
samples <- c("incl0801.srt.bam", "incl0802.srt.bam", "ivcl0801.srt.bam", "ivcl0802.srt.bam",
"incl1601.srt.bam", "incl1602.srt.bam", "ivcl1601.srt.bam", "ivcl1602.srt.bam",
"incl3201.srt.bam", "incl3202.srt.bam", "ivcl3201.srt.bam", "ivcl3202.srt.bam")
group <- c(rep("8cell", 4), rep("16cell", 4), rep("32cell", 4))
sample_info <- data.frame(sample = samples, group = group)
rownames(sample_info) <- samples
# 确保datExpr和样本信息的样本顺序一致
datExpr <- datExpr[match(rownames(sample_info), rownames(datExpr)), ]
# 样本聚类
sampleTree <- hclust(dist(datExpr), method = "average")
plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
# 加载必要的R包
library(WGCNA)
options(stringsAsFactors = FALSE)
allowWGCNAThreads()
f=getwd()
# 设置工作目录到数据文件所在的目录
setwd(f)  # 请将此路径修改为实际数据所在路径
# 加载计数数据
counts <- read.csv("merged.counts.txt", sep = "\t", header = TRUE, row.names = 1)
# 确保数据格式正确
datExpr <- as.data.frame(t(counts))
# 检查是否有缺失值
gsg <- goodSamplesGenes(datExpr, verbose = 3)
if (!gsg$allOK) {
# 如果有缺失值或异常值，进行处理
datExpr <- datExpr[gsg$goodSamples, gsg$goodGenes]
}
# 样本信息数据框
samples <- c("incl0801.srt.bam", "incl0802.srt.bam", "ivcl0801.srt.bam", "ivcl0802.srt.bam",
"incl1601.srt.bam", "incl1602.srt.bam", "ivcl1601.srt.bam", "ivcl1602.srt.bam",
"incl3201.srt.bam", "incl3202.srt.bam", "ivcl3201.srt.bam", "ivcl3202.srt.bam")
group <- c(rep("8cell", 4), rep("16cell", 4), rep("32cell", 4))
sample_info <- data.frame(sample = samples, group = group)
rownames(sample_info) <- samples
# 确保datExpr和样本信息的样本顺序一致
datExpr <- datExpr[match(rownames(sample_info), rownames(datExpr)), ]
# 样本聚类
sampleTree <- hclust(dist(datExpr), method = "average")
plot(sampleTree, main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
View(sampleTree)
# 加载必要的R包
library(WGCNA)
options(stringsAsFactors = FALSE)
allowWGCNAThreads()
f=getwd()
# 设置工作目录到数据文件所在的目录
setwd(f)  # 请将此路径修改为实际数据所在路径
# 加载计数数据
counts <- read.csv("merged.counts.txt", sep = "\t", header = TRUE, row.names = 1)
# 确保数据格式正确
datExpr <- as.data.frame(t(counts))
# 检查是否有缺失值
gsg <- goodSamplesGenes(datExpr, verbose = 3)
if (!gsg$allOK) {
# 如果有缺失值或异常值，进行处理
datExpr <- datExpr[gsg$goodSamples, gsg$goodGenes]
}
dim(gsg)
# 加载必要的R包
library(WGCNA)
options(stringsAsFactors = FALSE)
allowWGCNAThreads()
f=getwd()
# 设置工作目录到数据文件所在的目录
setwd(f)  # 请将此路径修改为实际数据所在路径
# 加载计数数据
counts <- read.csv("merged.counts.txt", sep = "\t", header = TRUE, row.names = 1)
dim(counts)
# 确保数据格式正确
datExpr <- as.data.frame(t(counts))
# 检查是否有缺失值
gsg <- goodSamplesGenes(datExpr, verbose = 3)
if (!gsg$allOK) {
# 如果有缺失值或异常值，进行处理
datExpr <- datExpr[gsg$goodSamples, gsg$goodGenes]
}
dim(gsg)
dim(datExpr)
# 加载计数数据
counts <- read.csv("merged.counts.txt", sep = "\t", header = TRUE, row.names = 1)
dim(counts)
# 确保数据格式正确
datExpr <- as.data.frame(t(counts))
dim(datExpr)
# 检查是否有缺失值
gsg <- goodSamplesGenes(datExpr, verbose = 3)
if (!gsg$allOK) {
# 如果有缺失值或异常值，进行处理
datExpr <- datExpr[gsg$goodSamples, gsg$goodGenes]
}
dim(gsg)
# 样本信息数据框
samples <- c("incl0801.srt.bam", "incl0802.srt.bam", "ivcl0801.srt.bam", "ivcl0802.srt.bam",
"incl1601.srt.bam", "incl1602.srt.bam", "ivcl1601.srt.bam", "ivcl1602.srt.bam",
"incl3201.srt.bam", "incl3202.srt.bam", "ivcl3201.srt.bam", "ivcl3202.srt.bam")
group <- c(rep("8cell", 4), rep("16cell", 4), rep("32cell", 4))
sample_info <- data.frame(sample = samples, group = group)
rownames(sample_info) <- samples
# The following setting is important, do not omit.
options(stringsAsFactors = FALSE)
# Read in the female liver data set
femData = read.table("./ExpData_WGCNA.txt")
# Take a quick look at what is in the data set:
dim(femData)
## [1] 3600  143
head(names(femData))
## [1] "substanceBXH"   "gene_symbol"    "LocusLinkID"    "ProteomeID"
## [5] "cytogeneticLoc" "CHROMOSOME"
datExpr0 = as.data.frame(t(femData[, -c(1:8)]))
names(datExpr0) = femData$substanceBXH
rownames(datExpr0) = names(femData)[-c(1:8)]
gsg = goodSamplesGenes(datExpr0, verbose = 3)
if(!require(WGCNA)){
BiocManager::install("WGCNA")
}
library(WGCNA)
gsg = goodSamplesGenes(datExpr0, verbose = 3)
##  Flagging genes and samples with too many missing values...
##   ..step 1
gsg$allOK
#install.packages("WGCNA")
#BiocManager::install('WGCNA')
library(WGCNA)
options(stringsAsFactors = FALSE)
enableWGCNAThreads()
## 读取txt文件格式数据
WGCNA.fpkm = read.table("ExpData_WGCNA.txt",header=T,
comment.char = "",
check.names=F)
###############
# 读取csv文件格式
#WGCNA.fpkm = read.csv("ExpData_WGCNA.csv", header = T, check.names = F)
dim(WGCNA.fpkm)
names(WGCNA.fpkm)
datExpr0 = as.data.frame(t(WGCNA.fpkm[,-1]))
dim(datExpr0)
names(datExpr0) = WGCNA.fpkm$sample;##########如果第一行不是ID命名，就写成fpkm[,1]
rownames(datExpr0) = names(WGCNA.fpkm[,-1])
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
if (!gsg$allOK)
{
if (sum(!gsg$goodGenes)>0)
printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")))
if (sum(!gsg$goodSamples)>0)
printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")))
# Remove the offending genes and samples from the data:
datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}
##filter
meanFPKM=0.99  ###--过滤标准，可以修改
n=nrow(datExpr0)
datExpr0[n+1,]=apply(datExpr0[c(1:nrow(datExpr0)),],2,mean)
datExpr0=datExpr0[1:n,datExpr0[n+1,] > meanFPKM]
# for meanFpkm in row n+1 and it must be above what you set--select meanFpkm>opt$meanFpkm(by rp)
filtered_fpkm=t(datExpr0)
filtered_fpkm=data.frame(rownames(filtered_fpkm),filtered_fpkm)
names(filtered_fpkm)[1]="sample"
head(filtered_fpkm)
write.table(filtered_fpkm, file="mRNA.filter.txt",
row.names=F, col.names=T,quote=FALSE,sep="\t")
sampleTree = hclust(dist(datExpr0), method = "average")
pdf(file = "1.sampleClustering.pdf", width = 15, height = 8)
par(cex = 0.6)
par(mar = c(0,6,6,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 2,
cex.axis = 1.5, cex.main = 2)
### Plot a line to show the cut
#abline(h = 180, col = "red")##剪切高度不确定，故无红线
dev.off()
######3#####第二步：样本分类。
traitData = read.table("sample.txt",row.names=1,header=T,comment.char = "",check.names=F)
allTraits = traitData
dim(allTraits)
names(allTraits)
## 形成一个类似于表达数据的数据框架
fpkmSamples = rownames(datExpr0)
dim(fpkmSamples)
traitSamples =rownames(allTraits)
head(traitSamples)
traitRows = match(fpkmSamples,traitSamples)
head(traitRows)
datTraits = allTraits[traitRows,]
head(datTraits)
dim(datTraits)
collectGarbage()
sampleTree2 = hclust(dist(datExpr0), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE)
pdf(file="2.Sample_dendrogram_and_trait_heatmap.pdf",width=20,height=12)
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(datTraits),
main = "Sample dendrogram and trait heatmap",cex.colorLabels = 1.5, cex.dendroLabels = 1, cex.rowText = 2)
dev.off()
enableWGCNAThreads()
## 选择软件认为是最好的softpower值
softPower =sft$powerEstimate
powers <- c(1:10, seq(from = 12, to 20, by 2))
part1 <- 1:10
part2 <- seq(from = 12, to 20, by 2)
part2 <- seq(from = 12,to20,by2)
powers <- c(part1, part2)
part2 <- seq(from = 12,to 20,by 2)
# 选择一系列可能的软阈值
powers <- c(c(1:10), seq(from = 12,to=20,by=2))
# 计算这些软阈值下的网络拓扑特性
sft <- pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# 计算这些软阈值下的网络拓扑特性
sft <- pickSoftThreshold(datExpr0, powerVector = powers, verbose = 5)
# 查看结果
sft$fitIndices
#---
# 自己设定softpower值
softPower = 12
adjacency = adjacency(datExpr0, power = softPower)
#install.packages("WGCNA")
#BiocManager::install('WGCNA')
rm(list = ls())
library(WGCNA)
options(stringsAsFactors = FALSE)
enableWGCNAThreads()
## 读取txt文件格式数据
WGCNA.fpkm = read.table("ExpData_WGCNA.txt",header=T,
comment.char = "",
check.names=F)
###############
# 读取csv文件格式
#WGCNA.fpkm = read.csv("ExpData_WGCNA.csv", header = T, check.names = F)
dim(WGCNA.fpkm)
names(WGCNA.fpkm)
datExpr0 = as.data.frame(t(WGCNA.fpkm[,-1]))
dim(datExpr0)
names(datExpr0) = WGCNA.fpkm$sample;##########如果第一行不是ID命名，就写成fpkm[,1]
rownames(datExpr0) = names(WGCNA.fpkm[,-1])
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
if (!gsg$allOK)
{
if (sum(!gsg$goodGenes)>0)
printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")))
if (sum(!gsg$goodSamples)>0)
printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")))
# Remove the offending genes and samples from the data:
datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}
##filter
meanFPKM=0.99  ###--过滤标准，可以修改
n=nrow(datExpr0)
datExpr0[n+1,]=apply(datExpr0[c(1:nrow(datExpr0)),],2,mean)
datExpr0=datExpr0[1:n,datExpr0[n+1,] > meanFPKM]
# for meanFpkm in row n+1 and it must be above what you set--select meanFpkm>opt$meanFpkm(by rp)
filtered_fpkm=t(datExpr0)
filtered_fpkm=data.frame(rownames(filtered_fpkm),filtered_fpkm)
names(filtered_fpkm)[1]="sample"
head(filtered_fpkm)
write.table(filtered_fpkm, file="mRNA.filter.txt",
row.names=F, col.names=T,quote=FALSE,sep="\t")
sampleTree = hclust(dist(datExpr0), method = "average")
pdf(file = "1.sampleClustering.pdf", width = 15, height = 8)
par(cex = 0.6)
par(mar = c(0,6,6,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 2,
cex.axis = 1.5, cex.main = 2)
### Plot a line to show the cut
#abline(h = 180, col = "red")##剪切高度不确定，故无红线
dev.off()
######3#####第二步：样本分类。
traitData = read.table("sample.txt",row.names=1,header=T,comment.char = "",check.names=F)
allTraits = traitData
dim(allTraits)
names(allTraits)
## 形成一个类似于表达数据的数据框架
fpkmSamples = rownames(datExpr0)
dim(fpkmSamples)
traitSamples =rownames(allTraits)
head(traitSamples)
traitRows = match(fpkmSamples,traitSamples)
head(traitRows)
datTraits = allTraits[traitRows,]
head(datTraits)
dim(datTraits)
collectGarbage()
sampleTree2 = hclust(dist(datExpr0), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE)
pdf(file="2.Sample_dendrogram_and_trait_heatmap.pdf",width=20,height=12)
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(datTraits),
main = "Sample dendrogram and trait heatmap",cex.colorLabels = 1.5, cex.dendroLabels = 1, cex.rowText = 2)
dev.off()
enableWGCNAThreads()
# 选择一系列可能的软阈值
powers <- c(c(1:10), seq(from = 12,to=20,by=2))
# 计算这些软阈值下的网络拓扑特性
sft <- pickSoftThreshold(datExpr0, powerVector = powers, verbose = 5)
# 查看结果
sft$fitIndices
#---
# 自己设定softpower值
##最接近于1的值为12
softPower = 12
adjacency = adjacency(datExpr0, power = softPower)
TOM = TOMsimilarity(adjacency);
dissTOM = 1-TOM
geneTree = hclust(as.dist(dissTOM), method = "average");
pdf(file="4_Gene clustering on TOM-based dissimilarity.pdf",width=24,height=18)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
labels = FALSE, hang = 0.04)
dev.off()
minModuleSize = 30
# Module identification using dynamic tree cut:
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
deepSplit = 2, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize);
table(dynamicMods)
# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Plot the dendrogram and colors underneath
#sizeGrWindow(8,6)
pdf(file="5_Dynamic Tree Cut.pdf",width=8,height=6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram and module colors")
dev.off()
MEList = moduleEigengenes(datExpr0, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average")
# Plot the result
#sizeGrWindow(7, 6)
pdf(file="6_Clustering of module eigengenes.pdf",width=7,height=6)
plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
# Plot the result
#sizeGrWindow(7, 6)
pdf(file="6_Clustering of module eigengenes.pdf",width=7,height=6)
plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
######剪切高度可修改
MEDissThres = 0.4
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
dev.off()
MEList = moduleEigengenes(datExpr0, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average")
# Plot the result
#sizeGrWindow(7, 6)
pdf(file="6_Clustering of module eigengenes.pdf",width=7,height=6)
plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
######剪切高度可修改
MEDissThres = 0.4
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
dev.off()
mergeCloseModules= mergeCloseModules(datExpr0, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs
table(mergedColors)
#sizeGrWindow(12, 9)
pdf(file="7_merged dynamic.pdf", width = 9, height = 6)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
